/**
 * SQL statement generator for postgreSQL
 * @author Ben Lue
 * @copyright 2023 ~ 2025 Conwell Inc.
*/
var  _debug = false,
	 _NL = ' ',
	 _noArgOP = ['IS NOT NULL', 'IS NULL'];

/* turn on/off debug */
exports.setDebug = function setDebug(b)  {
	_NL = (_debug = b)  ?  '\n' : ' ';
};


exports.createTable = function(schema)  {
	let  debug = _debug || schema.debug,
		 sql = `CREATE TABLE "${schema.title}"\n(\n`;
		 
	schema.columns.forEach(c => {
		let  s = `  "${c.title}"\t\t${mapDataType(c.type)}`;

		if (c.options)  {
			const  opt = c.options;
			if (opt.notNull)
				s += ' NOT NULL';
			if (opt.hasOwnProperty('default'))
				s += ' DEFAULT ' + opt.default;
			if (opt.autoInc)
				s += ' GENERATED BY DEFAULT AS IDENTITY';
		}
		sql += s + ',\n'
	})

	sql += '  PRIMARY KEY (';
	let  pk = '';
	for (let i in schema.primary)  {
		if (i > 0)
			pk += ', ';
		pk += '"' + schema.primary[i] + '"';
	}
	sql += pk + ')\n)';

	// adding table options
	if (schema.options && schema.options.comment)
		// PostgreSQL uses COMMENT ON TABLE syntax
		sql += ';\nCOMMENT ON TABLE "' + schema.title + '" IS \'' + schema.options.comment + '\'';
	sql += ';';

	if (debug)
		console.log('SQL[Create table]-----\n' + sql);
	return  sql;
};


exports.alterTable = function(schema)  {
	let  sql = `ALTER TABLE "${schema.title}"\n`,
		 alterSpec,
		 debug = _debug || schema.debug;

	if (schema.add)  {
		if (schema.add.column)  {
			let  columns = schema.add.column;
			for (let i in columns)  {
				let  c = columns[i],
					 s = `ADD COLUMN "${c.title}"\t${mapDataType(c.type)}`;

				if (c.options)  {
					var  opt = c.options;
					if (opt.notNull)
						s += ' NOT NULL';
					if (opt.hasOwnProperty('default'))
						s += ' DEFAULT ' + opt.default;
					if (opt.autoInc)
						s += ' GENERATED BY DEFAULT AS IDENTITY';
				}
				if (alterSpec)
					alterSpec += ',\n' + s;
				else
					alterSpec = s;
			}
		}

		if (schema.add.index)  {
			let  indexes = schema.add.index;
			for (let key in indexes)  {
				let  idx = indexes[key],
					 isUnique = idx.unique  ?  ' UNIQUE' : '';

				let  idxSQL = '';
				for (let i in idx.columns)  {
					if (idxSQL)
						idxSQL += ', "' + idx.columns[i] + '"';
					else
						idxSQL = '"' + idx.columns[i] + '"';
				}

				// PostgreSQL CREATE INDEX syntax is different
				let  s = `CREATE${isUnique} INDEX "${key}" ON "${schema.title}" (${idxSQL})`;
				if (alterSpec)
					alterSpec += ';\n' + s;
				else
					alterSpec = s;
			}
		}

		if (schema.add.foreignKey)  {
			let  fkeys = schema.add.foreignKey;
			for (let key in fkeys)  {
				let  fk = fkeys[key],
					 delInt = 'RESTRICT',
					 updInt = 'RESTRICT',
					 reference = fk.reference;

				if (fk.integrity)  {
					delInt = fk.integrity.delete ? fk.integrity.delete.toUpperCase() : delInt;
					updInt = fk.integrity.update ? fk.integrity.update.toUpperCase() : updInt;
				}

				let  idx = reference.indexOf('.'),
					 refTable = reference.substring(0, idx),
					 refCol = reference.substring(idx+1),
					 s = `ADD CONSTRAINT "${key}" FOREIGN KEY ("${fk.key}") REFERENCES "${refTable}" ("${refCol}") ON DELETE ${delInt} ON UPDATE ${updInt}`;
				if (alterSpec)
					alterSpec += ',\n' + s;
				else
					alterSpec = s;
			}
		}
	}
	
	if (schema.alter)  {
		if (schema.alter.column)  {
			let  columns = schema.alter.column;
			for (let i in columns)  {
				let  c = columns[i],
					 s;
				
				if (c.name)
					s = `ALTER COLUMN "${c.title}" RENAME TO "${c.name}"`;
				else
					s = `ALTER COLUMN "${c.title}" TYPE ${mapDataType(c.type)}`;
				
				if (s)	{
					if (alterSpec)
						alterSpec += ',\n' + s;
					else
						alterSpec = s;
				}
			}
		}
	}

	if (schema.drop)  {
		if (schema.drop.column)  {
			let  columns = schema.drop.column;
			for (let i in columns)  {
				let  s = `DROP COLUMN "${columns[i]}"`;
				if (alterSpec)
					alterSpec += ',\n' + s;
				else
					alterSpec = s;
			}
		}

		if (schema.drop.index)  {
			let  indexes = schema.drop.index;
			for (let i in indexes)  {
				let  s = `DROP INDEX "${indexes[i]}"`;
				if (alterSpec)
					alterSpec += ';\n' + s;
				else
					alterSpec = s;
			}
		}

		if (schema.drop.foreignKey)  {
			let  keys = schema.drop.foreignKey;
			for (let i in keys)  {
				let  s = `DROP CONSTRAINT "${keys[i]}"`;
				if (alterSpec)
					alterSpec += ',\n' + s;
				else
					alterSpec = s;
			}
		}
	}

	sql += alterSpec + ';';

	if (debug)
		console.log('SQL[Alter table]-----\n' + sql);
	return  sql;
};


exports.toSQL = function(cmd, data, query, p)  {
	const  debug = cmd.debug || _debug

	let  sql

	switch (cmd.op)  {
		case 'query':
			sql = genQuery(cmd, query, p, debug);
			break;

		case 'list':
			sql = genList(cmd, query, p, debug);
			break;
			
		// we don't use listCount for postgreSQL
		// case  'listCount':
		// 	sql = genListCount();
		// 	break;

		case 'insert':
			sql = genInsert(cmd, data, p, debug);
			break;

		case 'update':
			sql = genUpdate(cmd, data, query, p, debug);
			break;

		case 'delete':
			sql = genDelete(cmd, query, p, debug);
			break;
	}
	return  sql;
};


function  genQuery(cmd, q, p, debug)  {
	let  sql = composeQ(cmd, q, p, false, debug)

	if (sql)
		sql += _NL + 'LIMIT 1;';
	else
		sql += ';';

	return  sql;
};


function genList(cmd, q, p, debug)  {
	const  range = cmd.range,
		   isGetCount = range  ?  true : false

	let  sql = composeQ( cmd, q, p, isGetCount, debug )
	if (sql) {
		if (isGetCount)
			sql += `${_NL}LIMIT ${range.getPageSize()} OFFSET ${range.getIndex()};`;
		else
			sql += ';';
	}

	return  sql;
};


function  genInsert(cmd, data, p, debug)  {
	if (!data)
		throw  new Error('Missing insert data');

	const  schema = cmd.tableSchema,
		   expr = cmd.expr

	let  tableSpec = rectifyTable(expr.table, true),
		 fields = expr.columns;
		 
	if (expr.table.join)
		fields = mainTableColumn(tableSpec, fields);

	let  sql = 'INSERT INTO "' + tableSpec.table + '" ("',
		 notFirst = false;
	fields.forEach( function(f) {
		if (data.hasOwnProperty(f))  {
			if (notFirst)
				sql += '", "';
			sql += f;
			notFirst = true;

			p.push( data[f] );
		}
	});

	sql += '") VALUES (';
	for (let i = 1, len = p.length; i <= len; i++)  {
		if (i > 1)
			sql += ', ';
		sql += '$' + i;
	}
	sql += `) RETURNING "${schema.primary[0]}";`;

	if (debug)  {
		console.log('SQL-----\n' + sql);
		console.log('Arguments:\n' + p);
	}

	return  sql;
};


function genUpdate(cmd, data, terms, p, debug)  {
	if (!data)
		throw  new Error('Missing update data');

	const  expr = cmd.expr
	let  tableSpec = rectifyTable( expr.table, true ),
		 fields = expr.columns;
		 
	if (expr.table.join)
		fields = mainTableColumn(tableSpec, fields);

	let  sql = `UPDATE "${tableSpec.table}"${_NL}SET "`,
		 notFirst,
		 paramIndex = 1;
	fields.forEach( function(f) {
		if (data.hasOwnProperty(f))  {
			if (notFirst)
				sql += ', "';
			sql += f + '"=$' + paramIndex++;
			notFirst = true;

			p.push( data[f] );
		}
	});

	// where...
	let  filter = expr.table.join  ?  mainTableFilter(tableSpec, expr.filters) : expr.filters;
	if (filter)  {
		const  colNameList = Object.keys(cmd.tableSchema.columns),
			   s = matchFilter(colNameList, filter, terms, p)

		if (s)
			sql += `${_NL}WHERE ${s}`
	}
	sql += ';';

	if (debug)  {
		console.log('SQL-----\n' + sql);
		console.log('Arguments:\n' + p);
	}

	return  sql;
};


function genDelete(cmd, terms, p, debug)  {
	const  expr = cmd.expr
	let  tableSpec = rectifyTable( expr.table, true ),
		 sql = `DELETE FROM "${tableSpec.table}"`;

	// where...
	let  filter = expr.table.join  ?  mainTableFilter(tableSpec, expr.filters) : expr.filters;
	if (filter)  {
		const  colNameList = Object.keys(cmd.tableSchema.columns),
			   s = matchFilter(colNameList, filter, terms, p)

		if (s)
			sql += `${_NL}WHERE ${s}`
	}
	sql += ';';

	if (debug)  {
		console.log('SQL-----\n' + sql);
		console.log('Arguments:\n' + p);
	}

	return  sql;
};


function  genListCount()  {
	// PostgreSQL doesn't have FOUND_ROWS(), use a separate COUNT query
	// return  'SELECT COUNT(*) AS ct FROM (%LAST_QUERY%) AS count_query;';
	return  'GET DIAGNOSTICS integer_var = ROW_COUNT;'
}


function composeQ(cmd, q, p, isGetCount, debug)  {
	const  expr = cmd.expr,
		   schema = cmd.tableSchema,
		   tableColumns = Object.keys(schema.columns)
	// console.log('table schema: ' + JSON.stringify(schema, null, 4))

	let  table = expr.table,
		 fields = (expr.columns || []).map(f => tableColumnName(f, tableColumns)),
		 sql = 'SELECT ',
		 notFirst = false

	// Handle case where fields is empty or undefined
	if (fields.length === 0)
		sql += '*';
	/*
	else if (fld) {
		// pick up only selected fields
		let  hasSelectedFields = false;
		fields.forEach( f => {
			if (fld.indexOf(f) >= 0)  {
				if (notFirst)
					sql += ', ';
				else
					notFirst = true;

				sql += f;
				hasSelectedFields = true;
			}
		});
		
		// If no fields were selected, fall back to *
		if (!hasSelectedFields)
			sql += '*';
	}
	*/
	else {
		fields.forEach( f => {
			if (notFirst)
				sql += ', ';
			else
				notFirst = true;

			sql += f;
		});
	}

	if (isGetCount)
		sql += ', COUNT(*) OVER() AS _total_entries';

	// from...
	sql += _NL + 'FROM ' + aliasTableName(rectifyTable(table))

	// join...
	sql = genJoin(sql, table)

	// where...
	let  filter = expr.filters;
	if (filter)  {
		const  s = matchFilter(tableColumns, filter, q, p)

		if (s)
			sql += `${_NL}WHERE ${s}`
	}

	// extra
	if (expr.extra)
		sql += _NL + expr.extra

	if (debug)  {
		console.log('SQL-----\n' + sql)
		console.log('Arguments:\n' + p)
	}

	return  sql
};


/**
 * Generated the JOIN statement
 * @param {*} sql the SQL statment that has been generated thus far.
 * @param {*} table the table schema
 */
function  genJoin(sql, table)  {
	if (table.join)  {
		table.join.forEach(jt => {
			sql += _NL;
			if (jt.type)
				sql += ' ' + jt.type + ' ';
			sql += 'JOIN ' + aliasTableName(jt.table);

			if (jt.use)
				sql += ' USING("' + jt.use + '")';
			else  {
				let  onWhat = jt.on || jt.onWhat

				if (onWhat.indexOf('=') < 0)  {
					onWhat = tableColumnName(onWhat)
					// this is a short form as x.field, and we'll make it to x.field=y.field
					let  idx = onWhat.indexOf('.')

					// TODO: missing the syntax error handling
					if (idx > 0)  {
						const  jfield = onWhat.substring(idx),
							   tbName = rectifyTable({name: jt.table}, true);
						onWhat += '=' + (tbName.alias || tbName.table) + jfield;
					}
				}
				else  {
					const  parts = onWhat.split('=')
					onWhat = `${tableColumnName(parts[0])}=${tableColumnName(parts[1])}`
				}
				sql += ' ON ' + onWhat;
			}
		});
	}
	return  sql;
}


function  aliasTableName(name)  {
	const  parts = name.split(' ')

	let  aliasName;
	if (parts.length == 3)
		aliasName = `"${parts[0]}" AS ${parts[2]}`
	else if (parts.length == 2)
		aliasName = `"${parts[0]}" AS ${parts[1]}`
	else
		aliasName = `"${name}"`
		
	return  aliasName;
}


function  tableColumnName(name, colNameList = [])  {
	const  toFullName = function(colName)  {
		const  parts = colName.split('.')

		if (parts.length == 2)
			return  `${parts[0]}."${parts[1]}"`
		else
			return  colNameList.includes(colName) ? `"${colName}"` : colName
	}
	
	name = name.trim()
	const  parts = name.split(' ')
	let  fullName;
	if (parts.length == 3)
		fullName = `${toFullName(parts[0])} AS "${parts[2]}"`
	else if (parts.length == 2)
		fullName = `${toFullName(parts[0])} AS "${parts[1]}"`
	else
		fullName = toFullName(name)

	return  fullName
}


function  mainTableColumn(tableSpec, fields)  {
	let  nf = [];
	fields.forEach( function(f) {
		const  idx = f.indexOf('.');
		if (idx > 0)  {
			// filter out columns from other tables
			const  tbName = f.substring(0, idx);
			if (tbName === tableSpec.alias || tbName === tableSpec.table)
				nf.push( f.substring(idx+1) );
		}
	});
	
	return  nf;
}


/**
 * remove all query terms not applicable to the main table
 */
function  mainTableFilter(tableSpec, filter)  {
	const  op = filter.op.toUpperCase();

	if (op === 'AND' || op === 'OR')  {
		const  nfilters = [];

		filter.filters.forEach(function(f)  {
			const  mf = mainTableFilter(tableSpec, f);
			if (mf)
				nfilters.push( mf );
		});
		
		if (nfilters.length)  {
			if (nfilters.length === 1)
				return  nfilters[0];
				
			return  {op: op, filters: nfilters};
		}
		return  null;
	}

	let  fname = filter.name,
		   idx = fname.indexOf('.');

	if (idx > 0)  {
		const  alias = fname.substring(0, idx);
		if (alias !== tableSpec.alias && alias !== tableSpec.table)
			return  null;
			
		fname = fname.substring(idx+1);
	}
	
	return  {op: op, name: fname};
};


/**
 * q: input query parameter
 * p: the produced parameters for the prepared statement
 */
function  matchFilter(colNameList, filter, q, p)  {
	// let's deal with the short cut first
	if (typeof filter === 'string')
		filter = {name: filter, op: '='};
	else  if (Array.isArray(filter))
		filter = {op: 'AND', filters: filter}
	else  if (Object.getOwnPropertyNames(filter).length === 1)  {
		const  key = Object.keys(filter)[0],
			   fvalue = filter[key];

		if (Array.isArray(fvalue))  {
			filter.filters = fvalue;
			filter.op = key;
			delete  filter[key];
		}
		else
			filter = {
					name: key,
					op: fvalue
				 };
	}
	
	// now we're ready to roll...
	const  op = filter.op.toUpperCase()
	let  sql = ''

	if (op === 'AND' || op === 'OR')  {
		let  hit = false;

		filter.filters.forEach(f => {
			const  s = matchFilter(colNameList, f, q, p);
			if (s)  {
				sql = sql  ?  `${sql} ${op} ${s}` : s;
				hit = true;
			}
		});
		if (hit)
			sql = '(' + sql + ')';
	}
	else  {
		// this section handles a single filter
		let  fname = filter.name,
			 idx = fname.indexOf('.');

		if (idx > 0)
			fname = fname.substring(idx+1);

		if (q.hasOwnProperty(fname))  {
			// sql = '"' + (filter.field || filter.name) + '"';
			sql = tableColumnName(filter.field || filter.name, colNameList)
			if (op)  {
				sql += ' ' + op;
				
				if (op === 'IN')  {
					const  para = q[fname];
					if (Object.prototype.toString.call(para) === '[object Array]' && para.length) {
						sql += ' (';
						for (let i in para)  {
							p.push(para[i]);

							if (i > 0)	sql += ', ';
							sql += '$' + p.length;
						}
						sql += ')';
					}
					else
						throw 'Parameters for the IN clause should be a non-empty array';
				}
				else  if (_noArgOP.indexOf(op) < 0)  {
					if (!filter.noArg)  {
						const  value = q[fname];
						// Check if value starts with @ for column reference
						if (typeof value === 'string' && value.startsWith('@'))  {
							// Remove @ and use as column name (no parameter)
							sql += ' ' + tableColumnName(value.substring(1), colNameList);
						}
						else  {
							// Normal parameter handling
							p.push( value );
							sql += ' $' + p.length;
						}
					}
				}
			}
			else  {
				const  value = q[fname];
				// Check if value starts with @ for column reference
				if (typeof value === 'string' && value.startsWith('@'))  {
					// For cases without explicit operator, treat as equality with column reference
					sql += ' = ' + tableColumnName(value.substring(1), colNameList);
				}
				else  {
					// For cases without explicit operator, treat as equality with parameter
					p.push( value );
					sql += ' = $' + p.length;
				}
			}
		}
	}

	return  sql;
}


function  rectifyTable(table, fullSpec)  {
	let  tbName = table.name,
		 idx = tbName.indexOf('.');
	if (idx > 0)
		tbName = tbName.substring(idx+1);
		 
	if (fullSpec)  {
		const  spec = {},
			   idx0 = tbName.indexOf(' ');
			 
		if (idx0 > 0)  {
			const  parts = tbName.split(' ');
			tbName = parts[0];
			if (parts.length === 3)
				spec.alias = parts[2];
			else
				spec.alias = parts[1];
		}
		else
			spec.alias = tbName;
		
		spec.table = tbName;	
		return  spec;
	}
	
	return  tbName;
}


/**
 * Map MySQL data types to PostgreSQL equivalents
 */
function mapDataType(mysqlType) {
	if (!mysqlType) return mysqlType;
	
	const  type = mysqlType.toLowerCase();
	
	// Basic type mappings
	if (type.includes('int('))
		return 'INTEGER';
	if (type === 'tinyint(1)')
		return 'BOOLEAN';
	if (type.includes('varchar('))
		return type.replace('varchar', 'VARCHAR');
	if (type === 'text')
		return 'TEXT';
	if (type === 'datetime')
		return 'TIMESTAMP';
	if (type === 'date')
		return 'DATE';
	if (type === 'time')
		return 'TIME';
	if (type.includes('decimal('))
		return type.replace('decimal', 'DECIMAL');
	if (type.includes('float'))
		return 'REAL';
	if (type.includes('double'))
		return 'DOUBLE PRECISION';
	
	// Return as-is if no mapping found
	return mysqlType;
}